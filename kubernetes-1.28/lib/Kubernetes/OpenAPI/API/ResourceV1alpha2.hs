{-
   Kubernetes

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.1
   Kubernetes API version: release-1.28
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Kubernetes.OpenAPI.API.ResourceV1alpha2
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Kubernetes.OpenAPI.API.ResourceV1alpha2 where

import Kubernetes.OpenAPI.Core
import Kubernetes.OpenAPI.MimeTypes
import Kubernetes.OpenAPI.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** ResourceV1alpha2

-- *** createNamespacedPodSchedulingContext

-- | @POST \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/podschedulingcontexts@
-- 
-- create a PodSchedulingContext
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedPodSchedulingContext
  :: (Consumes CreateNamespacedPodSchedulingContext contentType, MimeRender contentType V1alpha2PodSchedulingContext)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha2PodSchedulingContext -- ^ "body"
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest CreateNamespacedPodSchedulingContext contentType V1alpha2PodSchedulingContext accept
createNamespacedPodSchedulingContext _  _ body (Namespace namespace) =
  _mkRequest "POST" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/podschedulingcontexts"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedPodSchedulingContext 
instance HasBodyParam CreateNamespacedPodSchedulingContext V1alpha2PodSchedulingContext 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedPodSchedulingContext Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam CreateNamespacedPodSchedulingContext DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam CreateNamespacedPodSchedulingContext FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam CreateNamespacedPodSchedulingContext FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedPodSchedulingContext mtype

-- | @application/json@
instance Produces CreateNamespacedPodSchedulingContext MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedPodSchedulingContext MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces CreateNamespacedPodSchedulingContext MimeYaml


-- *** createNamespacedResourceClaim

-- | @POST \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaims@
-- 
-- create a ResourceClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedResourceClaim
  :: (Consumes CreateNamespacedResourceClaim contentType, MimeRender contentType V1alpha2ResourceClaim)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha2ResourceClaim -- ^ "body"
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest CreateNamespacedResourceClaim contentType V1alpha2ResourceClaim accept
createNamespacedResourceClaim _  _ body (Namespace namespace) =
  _mkRequest "POST" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaims"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedResourceClaim 
instance HasBodyParam CreateNamespacedResourceClaim V1alpha2ResourceClaim 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedResourceClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam CreateNamespacedResourceClaim DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam CreateNamespacedResourceClaim FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam CreateNamespacedResourceClaim FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedResourceClaim mtype

-- | @application/json@
instance Produces CreateNamespacedResourceClaim MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedResourceClaim MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces CreateNamespacedResourceClaim MimeYaml


-- *** createNamespacedResourceClaimTemplate

-- | @POST \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaimtemplates@
-- 
-- create a ResourceClaimTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createNamespacedResourceClaimTemplate
  :: (Consumes CreateNamespacedResourceClaimTemplate contentType, MimeRender contentType V1alpha2ResourceClaimTemplate)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha2ResourceClaimTemplate -- ^ "body"
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest CreateNamespacedResourceClaimTemplate contentType V1alpha2ResourceClaimTemplate accept
createNamespacedResourceClaimTemplate _  _ body (Namespace namespace) =
  _mkRequest "POST" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaimtemplates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateNamespacedResourceClaimTemplate 
instance HasBodyParam CreateNamespacedResourceClaimTemplate V1alpha2ResourceClaimTemplate 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateNamespacedResourceClaimTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam CreateNamespacedResourceClaimTemplate DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam CreateNamespacedResourceClaimTemplate FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam CreateNamespacedResourceClaimTemplate FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes CreateNamespacedResourceClaimTemplate mtype

-- | @application/json@
instance Produces CreateNamespacedResourceClaimTemplate MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateNamespacedResourceClaimTemplate MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces CreateNamespacedResourceClaimTemplate MimeYaml


-- *** createResourceClass

-- | @POST \/apis\/resource.k8s.io\/v1alpha2\/resourceclasses@
-- 
-- create a ResourceClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
createResourceClass
  :: (Consumes CreateResourceClass contentType, MimeRender contentType V1alpha2ResourceClass)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha2ResourceClass -- ^ "body"
  -> KubernetesRequest CreateResourceClass contentType V1alpha2ResourceClass accept
createResourceClass _  _ body =
  _mkRequest "POST" ["/apis/resource.k8s.io/v1alpha2/resourceclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data CreateResourceClass 
instance HasBodyParam CreateResourceClass V1alpha2ResourceClass 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam CreateResourceClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam CreateResourceClass DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam CreateResourceClass FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam CreateResourceClass FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes CreateResourceClass mtype

-- | @application/json@
instance Produces CreateResourceClass MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces CreateResourceClass MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces CreateResourceClass MimeYaml


-- *** deleteCollectionNamespacedPodSchedulingContext

-- | @DELETE \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/podschedulingcontexts@
-- 
-- delete collection of PodSchedulingContext
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedPodSchedulingContext
  :: (Consumes DeleteCollectionNamespacedPodSchedulingContext contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedPodSchedulingContext contentType V1Status accept
deleteCollectionNamespacedPodSchedulingContext _  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/podschedulingcontexts"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedPodSchedulingContext 
instance HasBodyParam DeleteCollectionNamespacedPodSchedulingContext V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext Continue where
  applyOptionalParam req (Continue xs) =
    req `addQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `addQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `addQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `addQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `addQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `addQuery` toQuery ("propagationPolicy", Just xs)

-- | /Optional Param/ "resourceVersion" - resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `addQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "resourceVersionMatch" - resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext ResourceVersionMatch where
  applyOptionalParam req (ResourceVersionMatch xs) =
    req `addQuery` toQuery ("resourceVersionMatch", Just xs)

-- | /Optional Param/ "sendInitialEvents" - `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext SendInitialEvents where
  applyOptionalParam req (SendInitialEvents xs) =
    req `addQuery` toQuery ("sendInitialEvents", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam DeleteCollectionNamespacedPodSchedulingContext TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `addQuery` toQuery ("timeoutSeconds", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedPodSchedulingContext mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedPodSchedulingContext MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedPodSchedulingContext MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedPodSchedulingContext MimeYaml


-- *** deleteCollectionNamespacedResourceClaim

-- | @DELETE \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaims@
-- 
-- delete collection of ResourceClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedResourceClaim
  :: (Consumes DeleteCollectionNamespacedResourceClaim contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedResourceClaim contentType V1Status accept
deleteCollectionNamespacedResourceClaim _  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaims"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedResourceClaim 
instance HasBodyParam DeleteCollectionNamespacedResourceClaim V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim Continue where
  applyOptionalParam req (Continue xs) =
    req `addQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `addQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `addQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `addQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `addQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `addQuery` toQuery ("propagationPolicy", Just xs)

-- | /Optional Param/ "resourceVersion" - resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `addQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "resourceVersionMatch" - resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim ResourceVersionMatch where
  applyOptionalParam req (ResourceVersionMatch xs) =
    req `addQuery` toQuery ("resourceVersionMatch", Just xs)

-- | /Optional Param/ "sendInitialEvents" - `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim SendInitialEvents where
  applyOptionalParam req (SendInitialEvents xs) =
    req `addQuery` toQuery ("sendInitialEvents", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaim TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `addQuery` toQuery ("timeoutSeconds", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedResourceClaim mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedResourceClaim MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedResourceClaim MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedResourceClaim MimeYaml


-- *** deleteCollectionNamespacedResourceClaimTemplate

-- | @DELETE \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaimtemplates@
-- 
-- delete collection of ResourceClaimTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionNamespacedResourceClaimTemplate
  :: (Consumes DeleteCollectionNamespacedResourceClaimTemplate contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteCollectionNamespacedResourceClaimTemplate contentType V1Status accept
deleteCollectionNamespacedResourceClaimTemplate _  _ (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaimtemplates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionNamespacedResourceClaimTemplate 
instance HasBodyParam DeleteCollectionNamespacedResourceClaimTemplate V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate Continue where
  applyOptionalParam req (Continue xs) =
    req `addQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `addQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `addQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `addQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `addQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `addQuery` toQuery ("propagationPolicy", Just xs)

-- | /Optional Param/ "resourceVersion" - resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `addQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "resourceVersionMatch" - resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate ResourceVersionMatch where
  applyOptionalParam req (ResourceVersionMatch xs) =
    req `addQuery` toQuery ("resourceVersionMatch", Just xs)

-- | /Optional Param/ "sendInitialEvents" - `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate SendInitialEvents where
  applyOptionalParam req (SendInitialEvents xs) =
    req `addQuery` toQuery ("sendInitialEvents", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam DeleteCollectionNamespacedResourceClaimTemplate TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `addQuery` toQuery ("timeoutSeconds", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionNamespacedResourceClaimTemplate mtype

-- | @application/json@
instance Produces DeleteCollectionNamespacedResourceClaimTemplate MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionNamespacedResourceClaimTemplate MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteCollectionNamespacedResourceClaimTemplate MimeYaml


-- *** deleteCollectionResourceClass

-- | @DELETE \/apis\/resource.k8s.io\/v1alpha2\/resourceclasses@
-- 
-- delete collection of ResourceClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteCollectionResourceClass
  :: (Consumes DeleteCollectionResourceClass contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest DeleteCollectionResourceClass contentType V1Status accept
deleteCollectionResourceClass _  _ =
  _mkRequest "DELETE" ["/apis/resource.k8s.io/v1alpha2/resourceclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteCollectionResourceClass 
instance HasBodyParam DeleteCollectionResourceClass V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteCollectionResourceClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam DeleteCollectionResourceClass Continue where
  applyOptionalParam req (Continue xs) =
    req `addQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteCollectionResourceClass DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam DeleteCollectionResourceClass FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `addQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteCollectionResourceClass GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `addQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam DeleteCollectionResourceClass LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `addQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam DeleteCollectionResourceClass Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteCollectionResourceClass OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `addQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteCollectionResourceClass PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `addQuery` toQuery ("propagationPolicy", Just xs)

-- | /Optional Param/ "resourceVersion" - resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam DeleteCollectionResourceClass ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `addQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "resourceVersionMatch" - resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam DeleteCollectionResourceClass ResourceVersionMatch where
  applyOptionalParam req (ResourceVersionMatch xs) =
    req `addQuery` toQuery ("resourceVersionMatch", Just xs)

-- | /Optional Param/ "sendInitialEvents" - `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
instance HasOptionalParam DeleteCollectionResourceClass SendInitialEvents where
  applyOptionalParam req (SendInitialEvents xs) =
    req `addQuery` toQuery ("sendInitialEvents", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam DeleteCollectionResourceClass TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `addQuery` toQuery ("timeoutSeconds", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteCollectionResourceClass mtype

-- | @application/json@
instance Produces DeleteCollectionResourceClass MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteCollectionResourceClass MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteCollectionResourceClass MimeYaml


-- *** deleteNamespacedPodSchedulingContext

-- | @DELETE \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/podschedulingcontexts\/{name}@
-- 
-- delete a PodSchedulingContext
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedPodSchedulingContext
  :: (Consumes DeleteNamespacedPodSchedulingContext contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodSchedulingContext
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteNamespacedPodSchedulingContext contentType V1alpha2PodSchedulingContext accept
deleteNamespacedPodSchedulingContext _  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/podschedulingcontexts/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteNamespacedPodSchedulingContext 
instance HasBodyParam DeleteNamespacedPodSchedulingContext V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedPodSchedulingContext Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteNamespacedPodSchedulingContext DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedPodSchedulingContext GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `addQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedPodSchedulingContext OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `addQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedPodSchedulingContext PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `addQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedPodSchedulingContext mtype

-- | @application/json@
instance Produces DeleteNamespacedPodSchedulingContext MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedPodSchedulingContext MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteNamespacedPodSchedulingContext MimeYaml


-- *** deleteNamespacedResourceClaim

-- | @DELETE \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaims\/{name}@
-- 
-- delete a ResourceClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedResourceClaim
  :: (Consumes DeleteNamespacedResourceClaim contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteNamespacedResourceClaim contentType V1alpha2ResourceClaim accept
deleteNamespacedResourceClaim _  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaims/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteNamespacedResourceClaim 
instance HasBodyParam DeleteNamespacedResourceClaim V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedResourceClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteNamespacedResourceClaim DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedResourceClaim GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `addQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedResourceClaim OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `addQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedResourceClaim PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `addQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedResourceClaim mtype

-- | @application/json@
instance Produces DeleteNamespacedResourceClaim MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedResourceClaim MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteNamespacedResourceClaim MimeYaml


-- *** deleteNamespacedResourceClaimTemplate

-- | @DELETE \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaimtemplates\/{name}@
-- 
-- delete a ResourceClaimTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteNamespacedResourceClaimTemplate
  :: (Consumes DeleteNamespacedResourceClaimTemplate contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceClaimTemplate
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest DeleteNamespacedResourceClaimTemplate contentType V1alpha2ResourceClaimTemplate accept
deleteNamespacedResourceClaimTemplate _  _ (Name name) (Namespace namespace) =
  _mkRequest "DELETE" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaimtemplates/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteNamespacedResourceClaimTemplate 
instance HasBodyParam DeleteNamespacedResourceClaimTemplate V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteNamespacedResourceClaimTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteNamespacedResourceClaimTemplate DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteNamespacedResourceClaimTemplate GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `addQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteNamespacedResourceClaimTemplate OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `addQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteNamespacedResourceClaimTemplate PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `addQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteNamespacedResourceClaimTemplate mtype

-- | @application/json@
instance Produces DeleteNamespacedResourceClaimTemplate MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteNamespacedResourceClaimTemplate MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteNamespacedResourceClaimTemplate MimeYaml


-- *** deleteResourceClass

-- | @DELETE \/apis\/resource.k8s.io\/v1alpha2\/resourceclasses\/{name}@
-- 
-- delete a ResourceClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
deleteResourceClass
  :: (Consumes DeleteResourceClass contentType)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceClass
  -> KubernetesRequest DeleteResourceClass contentType V1alpha2ResourceClass accept
deleteResourceClass _  _ (Name name) =
  _mkRequest "DELETE" ["/apis/resource.k8s.io/v1alpha2/resourceclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data DeleteResourceClass 
instance HasBodyParam DeleteResourceClass V1DeleteOptions 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam DeleteResourceClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam DeleteResourceClass DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "gracePeriodSeconds" - The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
instance HasOptionalParam DeleteResourceClass GracePeriodSeconds where
  applyOptionalParam req (GracePeriodSeconds xs) =
    req `addQuery` toQuery ("gracePeriodSeconds", Just xs)

-- | /Optional Param/ "orphanDependents" - Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
instance HasOptionalParam DeleteResourceClass OrphanDependents where
  applyOptionalParam req (OrphanDependents xs) =
    req `addQuery` toQuery ("orphanDependents", Just xs)

-- | /Optional Param/ "propagationPolicy" - Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.
instance HasOptionalParam DeleteResourceClass PropagationPolicy where
  applyOptionalParam req (PropagationPolicy xs) =
    req `addQuery` toQuery ("propagationPolicy", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes DeleteResourceClass mtype

-- | @application/json@
instance Produces DeleteResourceClass MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces DeleteResourceClass MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces DeleteResourceClass MimeYaml


-- *** getAPIResources

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/@
-- 
-- get available resources
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
getAPIResources
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest GetAPIResources MimeNoContent V1APIResourceList accept
getAPIResources  _ =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data GetAPIResources  
-- | @application/json@
instance Produces GetAPIResources MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces GetAPIResources MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces GetAPIResources MimeYaml


-- *** listNamespacedPodSchedulingContext

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/podschedulingcontexts@
-- 
-- list or watch objects of kind PodSchedulingContext
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedPodSchedulingContext
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedPodSchedulingContext MimeNoContent V1alpha2PodSchedulingContextList accept
listNamespacedPodSchedulingContext  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/podschedulingcontexts"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedPodSchedulingContext  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedPodSchedulingContext Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
instance HasOptionalParam ListNamespacedPodSchedulingContext AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `addQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedPodSchedulingContext Continue where
  applyOptionalParam req (Continue xs) =
    req `addQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedPodSchedulingContext FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `addQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedPodSchedulingContext LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `addQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedPodSchedulingContext Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListNamespacedPodSchedulingContext ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `addQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "resourceVersionMatch" - resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListNamespacedPodSchedulingContext ResourceVersionMatch where
  applyOptionalParam req (ResourceVersionMatch xs) =
    req `addQuery` toQuery ("resourceVersionMatch", Just xs)

-- | /Optional Param/ "sendInitialEvents" - `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
instance HasOptionalParam ListNamespacedPodSchedulingContext SendInitialEvents where
  applyOptionalParam req (SendInitialEvents xs) =
    req `addQuery` toQuery ("sendInitialEvents", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListNamespacedPodSchedulingContext TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `addQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedPodSchedulingContext Watch where
  applyOptionalParam req (Watch xs) =
    req `addQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListNamespacedPodSchedulingContext MimeJSON
-- | @application/json;stream=watch@
instance Produces ListNamespacedPodSchedulingContext MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedPodSchedulingContext MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedPodSchedulingContext MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListNamespacedPodSchedulingContext MimeYaml


-- *** listNamespacedResourceClaim

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaims@
-- 
-- list or watch objects of kind ResourceClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedResourceClaim
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedResourceClaim MimeNoContent V1alpha2ResourceClaimList accept
listNamespacedResourceClaim  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaims"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedResourceClaim  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedResourceClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
instance HasOptionalParam ListNamespacedResourceClaim AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `addQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedResourceClaim Continue where
  applyOptionalParam req (Continue xs) =
    req `addQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedResourceClaim FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `addQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedResourceClaim LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `addQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedResourceClaim Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListNamespacedResourceClaim ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `addQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "resourceVersionMatch" - resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListNamespacedResourceClaim ResourceVersionMatch where
  applyOptionalParam req (ResourceVersionMatch xs) =
    req `addQuery` toQuery ("resourceVersionMatch", Just xs)

-- | /Optional Param/ "sendInitialEvents" - `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
instance HasOptionalParam ListNamespacedResourceClaim SendInitialEvents where
  applyOptionalParam req (SendInitialEvents xs) =
    req `addQuery` toQuery ("sendInitialEvents", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListNamespacedResourceClaim TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `addQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedResourceClaim Watch where
  applyOptionalParam req (Watch xs) =
    req `addQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListNamespacedResourceClaim MimeJSON
-- | @application/json;stream=watch@
instance Produces ListNamespacedResourceClaim MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedResourceClaim MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedResourceClaim MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListNamespacedResourceClaim MimeYaml


-- *** listNamespacedResourceClaimTemplate

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaimtemplates@
-- 
-- list or watch objects of kind ResourceClaimTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listNamespacedResourceClaimTemplate
  :: Accept accept -- ^ request accept ('MimeType')
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ListNamespacedResourceClaimTemplate MimeNoContent V1alpha2ResourceClaimTemplateList accept
listNamespacedResourceClaimTemplate  _ (Namespace namespace) =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaimtemplates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListNamespacedResourceClaimTemplate  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListNamespacedResourceClaimTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
instance HasOptionalParam ListNamespacedResourceClaimTemplate AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `addQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListNamespacedResourceClaimTemplate Continue where
  applyOptionalParam req (Continue xs) =
    req `addQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListNamespacedResourceClaimTemplate FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `addQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListNamespacedResourceClaimTemplate LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `addQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListNamespacedResourceClaimTemplate Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListNamespacedResourceClaimTemplate ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `addQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "resourceVersionMatch" - resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListNamespacedResourceClaimTemplate ResourceVersionMatch where
  applyOptionalParam req (ResourceVersionMatch xs) =
    req `addQuery` toQuery ("resourceVersionMatch", Just xs)

-- | /Optional Param/ "sendInitialEvents" - `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
instance HasOptionalParam ListNamespacedResourceClaimTemplate SendInitialEvents where
  applyOptionalParam req (SendInitialEvents xs) =
    req `addQuery` toQuery ("sendInitialEvents", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListNamespacedResourceClaimTemplate TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `addQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListNamespacedResourceClaimTemplate Watch where
  applyOptionalParam req (Watch xs) =
    req `addQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListNamespacedResourceClaimTemplate MimeJSON
-- | @application/json;stream=watch@
instance Produces ListNamespacedResourceClaimTemplate MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListNamespacedResourceClaimTemplate MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListNamespacedResourceClaimTemplate MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListNamespacedResourceClaimTemplate MimeYaml


-- *** listPodSchedulingContextForAllNamespaces

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/podschedulingcontexts@
-- 
-- list or watch objects of kind PodSchedulingContext
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listPodSchedulingContextForAllNamespaces
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListPodSchedulingContextForAllNamespaces MimeNoContent V1alpha2PodSchedulingContextList accept
listPodSchedulingContextForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/podschedulingcontexts"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListPodSchedulingContextForAllNamespaces  

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
instance HasOptionalParam ListPodSchedulingContextForAllNamespaces AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `addQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListPodSchedulingContextForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `addQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListPodSchedulingContextForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `addQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListPodSchedulingContextForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `addQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListPodSchedulingContextForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListPodSchedulingContextForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListPodSchedulingContextForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `addQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "resourceVersionMatch" - resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListPodSchedulingContextForAllNamespaces ResourceVersionMatch where
  applyOptionalParam req (ResourceVersionMatch xs) =
    req `addQuery` toQuery ("resourceVersionMatch", Just xs)

-- | /Optional Param/ "sendInitialEvents" - `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
instance HasOptionalParam ListPodSchedulingContextForAllNamespaces SendInitialEvents where
  applyOptionalParam req (SendInitialEvents xs) =
    req `addQuery` toQuery ("sendInitialEvents", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListPodSchedulingContextForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `addQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListPodSchedulingContextForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `addQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListPodSchedulingContextForAllNamespaces MimeJSON
-- | @application/json;stream=watch@
instance Produces ListPodSchedulingContextForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListPodSchedulingContextForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListPodSchedulingContextForAllNamespaces MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListPodSchedulingContextForAllNamespaces MimeYaml


-- *** listResourceClaimForAllNamespaces

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/resourceclaims@
-- 
-- list or watch objects of kind ResourceClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listResourceClaimForAllNamespaces
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListResourceClaimForAllNamespaces MimeNoContent V1alpha2ResourceClaimList accept
listResourceClaimForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/resourceclaims"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListResourceClaimForAllNamespaces  

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
instance HasOptionalParam ListResourceClaimForAllNamespaces AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `addQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListResourceClaimForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `addQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListResourceClaimForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `addQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListResourceClaimForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `addQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListResourceClaimForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListResourceClaimForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListResourceClaimForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `addQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "resourceVersionMatch" - resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListResourceClaimForAllNamespaces ResourceVersionMatch where
  applyOptionalParam req (ResourceVersionMatch xs) =
    req `addQuery` toQuery ("resourceVersionMatch", Just xs)

-- | /Optional Param/ "sendInitialEvents" - `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
instance HasOptionalParam ListResourceClaimForAllNamespaces SendInitialEvents where
  applyOptionalParam req (SendInitialEvents xs) =
    req `addQuery` toQuery ("sendInitialEvents", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListResourceClaimForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `addQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListResourceClaimForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `addQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListResourceClaimForAllNamespaces MimeJSON
-- | @application/json;stream=watch@
instance Produces ListResourceClaimForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListResourceClaimForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListResourceClaimForAllNamespaces MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListResourceClaimForAllNamespaces MimeYaml


-- *** listResourceClaimTemplateForAllNamespaces

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/resourceclaimtemplates@
-- 
-- list or watch objects of kind ResourceClaimTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listResourceClaimTemplateForAllNamespaces
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListResourceClaimTemplateForAllNamespaces MimeNoContent V1alpha2ResourceClaimTemplateList accept
listResourceClaimTemplateForAllNamespaces  _ =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/resourceclaimtemplates"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListResourceClaimTemplateForAllNamespaces  

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
instance HasOptionalParam ListResourceClaimTemplateForAllNamespaces AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `addQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListResourceClaimTemplateForAllNamespaces Continue where
  applyOptionalParam req (Continue xs) =
    req `addQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListResourceClaimTemplateForAllNamespaces FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `addQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListResourceClaimTemplateForAllNamespaces LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `addQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListResourceClaimTemplateForAllNamespaces Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListResourceClaimTemplateForAllNamespaces Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "resourceVersion" - resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListResourceClaimTemplateForAllNamespaces ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `addQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "resourceVersionMatch" - resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListResourceClaimTemplateForAllNamespaces ResourceVersionMatch where
  applyOptionalParam req (ResourceVersionMatch xs) =
    req `addQuery` toQuery ("resourceVersionMatch", Just xs)

-- | /Optional Param/ "sendInitialEvents" - `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
instance HasOptionalParam ListResourceClaimTemplateForAllNamespaces SendInitialEvents where
  applyOptionalParam req (SendInitialEvents xs) =
    req `addQuery` toQuery ("sendInitialEvents", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListResourceClaimTemplateForAllNamespaces TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `addQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListResourceClaimTemplateForAllNamespaces Watch where
  applyOptionalParam req (Watch xs) =
    req `addQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListResourceClaimTemplateForAllNamespaces MimeJSON
-- | @application/json;stream=watch@
instance Produces ListResourceClaimTemplateForAllNamespaces MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListResourceClaimTemplateForAllNamespaces MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListResourceClaimTemplateForAllNamespaces MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListResourceClaimTemplateForAllNamespaces MimeYaml


-- *** listResourceClass

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/resourceclasses@
-- 
-- list or watch objects of kind ResourceClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
listResourceClass
  :: Accept accept -- ^ request accept ('MimeType')
  -> KubernetesRequest ListResourceClass MimeNoContent V1alpha2ResourceClassList accept
listResourceClass  _ =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/resourceclasses"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ListResourceClass  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ListResourceClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "allowWatchBookmarks" - allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
instance HasOptionalParam ListResourceClass AllowWatchBookmarks where
  applyOptionalParam req (AllowWatchBookmarks xs) =
    req `addQuery` toQuery ("allowWatchBookmarks", Just xs)

-- | /Optional Param/ "continue" - The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
instance HasOptionalParam ListResourceClass Continue where
  applyOptionalParam req (Continue xs) =
    req `addQuery` toQuery ("continue", Just xs)

-- | /Optional Param/ "fieldSelector" - A selector to restrict the list of returned objects by their fields. Defaults to everything.
instance HasOptionalParam ListResourceClass FieldSelector where
  applyOptionalParam req (FieldSelector xs) =
    req `addQuery` toQuery ("fieldSelector", Just xs)

-- | /Optional Param/ "labelSelector" - A selector to restrict the list of returned objects by their labels. Defaults to everything.
instance HasOptionalParam ListResourceClass LabelSelector where
  applyOptionalParam req (LabelSelector xs) =
    req `addQuery` toQuery ("labelSelector", Just xs)

-- | /Optional Param/ "limit" - limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
instance HasOptionalParam ListResourceClass Limit where
  applyOptionalParam req (Limit xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "resourceVersion" - resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListResourceClass ResourceVersion where
  applyOptionalParam req (ResourceVersion xs) =
    req `addQuery` toQuery ("resourceVersion", Just xs)

-- | /Optional Param/ "resourceVersionMatch" - resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
instance HasOptionalParam ListResourceClass ResourceVersionMatch where
  applyOptionalParam req (ResourceVersionMatch xs) =
    req `addQuery` toQuery ("resourceVersionMatch", Just xs)

-- | /Optional Param/ "sendInitialEvents" - `sendInitialEvents=true` may be set together with `watch=true`. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \"Bookmark\" event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with `\"k8s.io/initial-events-end\": \"true\"` annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When `sendInitialEvents` option is set, we require `resourceVersionMatch` option to also be set. The semantic of the watch request is as following: - `resourceVersionMatch` = NotOlderThan   is interpreted as \"data at least as new as the provided `resourceVersion`\"   and the bookmark event is send when the state is synced   to a `resourceVersion` at least as fresh as the one provided by the ListOptions.   If `resourceVersion` is unset, this is interpreted as \"consistent read\" and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - `resourceVersionMatch` set to any other value or unset   Invalid error is returned.  Defaults to true if `resourceVersion=\"\"` or `resourceVersion=\"0\"` (for backward compatibility reasons) and to false otherwise.
instance HasOptionalParam ListResourceClass SendInitialEvents where
  applyOptionalParam req (SendInitialEvents xs) =
    req `addQuery` toQuery ("sendInitialEvents", Just xs)

-- | /Optional Param/ "timeoutSeconds" - Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
instance HasOptionalParam ListResourceClass TimeoutSeconds where
  applyOptionalParam req (TimeoutSeconds xs) =
    req `addQuery` toQuery ("timeoutSeconds", Just xs)

-- | /Optional Param/ "watch" - Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
instance HasOptionalParam ListResourceClass Watch where
  applyOptionalParam req (Watch xs) =
    req `addQuery` toQuery ("watch", Just xs)
-- | @application/json@
instance Produces ListResourceClass MimeJSON
-- | @application/json;stream=watch@
instance Produces ListResourceClass MimeJsonstreamwatch
-- | @application/vnd.kubernetes.protobuf@
instance Produces ListResourceClass MimeVndKubernetesProtobuf
-- | @application/vnd.kubernetes.protobuf;stream=watch@
instance Produces ListResourceClass MimeVndKubernetesProtobufstreamwatch
-- | @application/yaml@
instance Produces ListResourceClass MimeYaml


-- *** patchNamespacedPodSchedulingContext

-- | @PATCH \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/podschedulingcontexts\/{name}@
-- 
-- partially update the specified PodSchedulingContext
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedPodSchedulingContext
  :: (Consumes PatchNamespacedPodSchedulingContext contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the PodSchedulingContext
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedPodSchedulingContext contentType V1alpha2PodSchedulingContext accept
patchNamespacedPodSchedulingContext _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/podschedulingcontexts/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedPodSchedulingContext 
instance HasBodyParam PatchNamespacedPodSchedulingContext Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedPodSchedulingContext Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedPodSchedulingContext DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedPodSchedulingContext FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam PatchNamespacedPodSchedulingContext FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedPodSchedulingContext Force where
  applyOptionalParam req (Force xs) =
    req `addQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedPodSchedulingContext MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedPodSchedulingContext MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedPodSchedulingContext MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedPodSchedulingContext MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedPodSchedulingContext MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedPodSchedulingContext MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedPodSchedulingContext MimeYaml


-- *** patchNamespacedPodSchedulingContextStatus

-- | @PATCH \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/podschedulingcontexts\/{name}\/status@
-- 
-- partially update status of the specified PodSchedulingContext
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedPodSchedulingContextStatus
  :: (Consumes PatchNamespacedPodSchedulingContextStatus contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the PodSchedulingContext
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedPodSchedulingContextStatus contentType V1alpha2PodSchedulingContext accept
patchNamespacedPodSchedulingContextStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/podschedulingcontexts/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedPodSchedulingContextStatus 
instance HasBodyParam PatchNamespacedPodSchedulingContextStatus Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedPodSchedulingContextStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedPodSchedulingContextStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedPodSchedulingContextStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam PatchNamespacedPodSchedulingContextStatus FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedPodSchedulingContextStatus Force where
  applyOptionalParam req (Force xs) =
    req `addQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedPodSchedulingContextStatus MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedPodSchedulingContextStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedPodSchedulingContextStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedPodSchedulingContextStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedPodSchedulingContextStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedPodSchedulingContextStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedPodSchedulingContextStatus MimeYaml


-- *** patchNamespacedResourceClaim

-- | @PATCH \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaims\/{name}@
-- 
-- partially update the specified ResourceClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedResourceClaim
  :: (Consumes PatchNamespacedResourceClaim contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the ResourceClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedResourceClaim contentType V1alpha2ResourceClaim accept
patchNamespacedResourceClaim _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaims/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedResourceClaim 
instance HasBodyParam PatchNamespacedResourceClaim Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedResourceClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedResourceClaim DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedResourceClaim FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam PatchNamespacedResourceClaim FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedResourceClaim Force where
  applyOptionalParam req (Force xs) =
    req `addQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedResourceClaim MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedResourceClaim MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedResourceClaim MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedResourceClaim MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedResourceClaim MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedResourceClaim MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedResourceClaim MimeYaml


-- *** patchNamespacedResourceClaimStatus

-- | @PATCH \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaims\/{name}\/status@
-- 
-- partially update status of the specified ResourceClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedResourceClaimStatus
  :: (Consumes PatchNamespacedResourceClaimStatus contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the ResourceClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedResourceClaimStatus contentType V1alpha2ResourceClaim accept
patchNamespacedResourceClaimStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaims/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedResourceClaimStatus 
instance HasBodyParam PatchNamespacedResourceClaimStatus Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedResourceClaimStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedResourceClaimStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedResourceClaimStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam PatchNamespacedResourceClaimStatus FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedResourceClaimStatus Force where
  applyOptionalParam req (Force xs) =
    req `addQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedResourceClaimStatus MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedResourceClaimStatus MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedResourceClaimStatus MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedResourceClaimStatus MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedResourceClaimStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedResourceClaimStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedResourceClaimStatus MimeYaml


-- *** patchNamespacedResourceClaimTemplate

-- | @PATCH \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaimtemplates\/{name}@
-- 
-- partially update the specified ResourceClaimTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchNamespacedResourceClaimTemplate
  :: (Consumes PatchNamespacedResourceClaimTemplate contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the ResourceClaimTemplate
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest PatchNamespacedResourceClaimTemplate contentType V1alpha2ResourceClaimTemplate accept
patchNamespacedResourceClaimTemplate _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PATCH" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaimtemplates/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchNamespacedResourceClaimTemplate 
instance HasBodyParam PatchNamespacedResourceClaimTemplate Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchNamespacedResourceClaimTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchNamespacedResourceClaimTemplate DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchNamespacedResourceClaimTemplate FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam PatchNamespacedResourceClaimTemplate FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchNamespacedResourceClaimTemplate Force where
  applyOptionalParam req (Force xs) =
    req `addQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchNamespacedResourceClaimTemplate MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchNamespacedResourceClaimTemplate MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchNamespacedResourceClaimTemplate MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchNamespacedResourceClaimTemplate MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchNamespacedResourceClaimTemplate MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchNamespacedResourceClaimTemplate MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchNamespacedResourceClaimTemplate MimeYaml


-- *** patchResourceClass

-- | @PATCH \/apis\/resource.k8s.io\/v1alpha2\/resourceclasses\/{name}@
-- 
-- partially update the specified ResourceClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
patchResourceClass
  :: (Consumes PatchResourceClass contentType, MimeRender contentType Body)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> Body -- ^ "body"
  -> Name -- ^ "name" -  name of the ResourceClass
  -> KubernetesRequest PatchResourceClass contentType V1alpha2ResourceClass accept
patchResourceClass _  _ body (Name name) =
  _mkRequest "PATCH" ["/apis/resource.k8s.io/v1alpha2/resourceclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data PatchResourceClass 
instance HasBodyParam PatchResourceClass Body 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam PatchResourceClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam PatchResourceClass DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
instance HasOptionalParam PatchResourceClass FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam PatchResourceClass FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | /Optional Param/ "force" - Force is going to \"force\" Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
instance HasOptionalParam PatchResourceClass Force where
  applyOptionalParam req (Force xs) =
    req `addQuery` toQuery ("force", Just xs)

-- | @application/apply-patch+yaml@
instance Consumes PatchResourceClass MimeApplyPatchyaml
-- | @application/json-patch+json@
instance Consumes PatchResourceClass MimeJsonPatchjson
-- | @application/merge-patch+json@
instance Consumes PatchResourceClass MimeMergePatchjson
-- | @application/strategic-merge-patch+json@
instance Consumes PatchResourceClass MimeStrategicMergePatchjson

-- | @application/json@
instance Produces PatchResourceClass MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces PatchResourceClass MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces PatchResourceClass MimeYaml


-- *** readNamespacedPodSchedulingContext

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/podschedulingcontexts\/{name}@
-- 
-- read the specified PodSchedulingContext
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedPodSchedulingContext
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodSchedulingContext
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedPodSchedulingContext MimeNoContent V1alpha2PodSchedulingContext accept
readNamespacedPodSchedulingContext  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/podschedulingcontexts/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedPodSchedulingContext  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedPodSchedulingContext Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedPodSchedulingContext MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedPodSchedulingContext MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedPodSchedulingContext MimeYaml


-- *** readNamespacedPodSchedulingContextStatus

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/podschedulingcontexts\/{name}\/status@
-- 
-- read status of the specified PodSchedulingContext
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedPodSchedulingContextStatus
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the PodSchedulingContext
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedPodSchedulingContextStatus MimeNoContent V1alpha2PodSchedulingContext accept
readNamespacedPodSchedulingContextStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/podschedulingcontexts/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedPodSchedulingContextStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedPodSchedulingContextStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedPodSchedulingContextStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedPodSchedulingContextStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedPodSchedulingContextStatus MimeYaml


-- *** readNamespacedResourceClaim

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaims\/{name}@
-- 
-- read the specified ResourceClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedResourceClaim
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedResourceClaim MimeNoContent V1alpha2ResourceClaim accept
readNamespacedResourceClaim  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaims/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedResourceClaim  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedResourceClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedResourceClaim MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedResourceClaim MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedResourceClaim MimeYaml


-- *** readNamespacedResourceClaimStatus

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaims\/{name}\/status@
-- 
-- read status of the specified ResourceClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedResourceClaimStatus
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedResourceClaimStatus MimeNoContent V1alpha2ResourceClaim accept
readNamespacedResourceClaimStatus  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaims/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedResourceClaimStatus  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedResourceClaimStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedResourceClaimStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedResourceClaimStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedResourceClaimStatus MimeYaml


-- *** readNamespacedResourceClaimTemplate

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaimtemplates\/{name}@
-- 
-- read the specified ResourceClaimTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readNamespacedResourceClaimTemplate
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceClaimTemplate
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReadNamespacedResourceClaimTemplate MimeNoContent V1alpha2ResourceClaimTemplate accept
readNamespacedResourceClaimTemplate  _ (Name name) (Namespace namespace) =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaimtemplates/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadNamespacedResourceClaimTemplate  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadNamespacedResourceClaimTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadNamespacedResourceClaimTemplate MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadNamespacedResourceClaimTemplate MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadNamespacedResourceClaimTemplate MimeYaml


-- *** readResourceClass

-- | @GET \/apis\/resource.k8s.io\/v1alpha2\/resourceclasses\/{name}@
-- 
-- read the specified ResourceClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
readResourceClass
  :: Accept accept -- ^ request accept ('MimeType')
  -> Name -- ^ "name" -  name of the ResourceClass
  -> KubernetesRequest ReadResourceClass MimeNoContent V1alpha2ResourceClass accept
readResourceClass  _ (Name name) =
  _mkRequest "GET" ["/apis/resource.k8s.io/v1alpha2/resourceclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)

data ReadResourceClass  

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReadResourceClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)
-- | @application/json@
instance Produces ReadResourceClass MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReadResourceClass MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReadResourceClass MimeYaml


-- *** replaceNamespacedPodSchedulingContext

-- | @PUT \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/podschedulingcontexts\/{name}@
-- 
-- replace the specified PodSchedulingContext
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedPodSchedulingContext
  :: (Consumes ReplaceNamespacedPodSchedulingContext contentType, MimeRender contentType V1alpha2PodSchedulingContext)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha2PodSchedulingContext -- ^ "body"
  -> Name -- ^ "name" -  name of the PodSchedulingContext
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedPodSchedulingContext contentType V1alpha2PodSchedulingContext accept
replaceNamespacedPodSchedulingContext _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/podschedulingcontexts/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedPodSchedulingContext 
instance HasBodyParam ReplaceNamespacedPodSchedulingContext V1alpha2PodSchedulingContext 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedPodSchedulingContext Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedPodSchedulingContext DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedPodSchedulingContext FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam ReplaceNamespacedPodSchedulingContext FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedPodSchedulingContext mtype

-- | @application/json@
instance Produces ReplaceNamespacedPodSchedulingContext MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedPodSchedulingContext MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedPodSchedulingContext MimeYaml


-- *** replaceNamespacedPodSchedulingContextStatus

-- | @PUT \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/podschedulingcontexts\/{name}\/status@
-- 
-- replace status of the specified PodSchedulingContext
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedPodSchedulingContextStatus
  :: (Consumes ReplaceNamespacedPodSchedulingContextStatus contentType, MimeRender contentType V1alpha2PodSchedulingContext)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha2PodSchedulingContext -- ^ "body"
  -> Name -- ^ "name" -  name of the PodSchedulingContext
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedPodSchedulingContextStatus contentType V1alpha2PodSchedulingContext accept
replaceNamespacedPodSchedulingContextStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/podschedulingcontexts/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedPodSchedulingContextStatus 
instance HasBodyParam ReplaceNamespacedPodSchedulingContextStatus V1alpha2PodSchedulingContext 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedPodSchedulingContextStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedPodSchedulingContextStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedPodSchedulingContextStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam ReplaceNamespacedPodSchedulingContextStatus FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedPodSchedulingContextStatus mtype

-- | @application/json@
instance Produces ReplaceNamespacedPodSchedulingContextStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedPodSchedulingContextStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedPodSchedulingContextStatus MimeYaml


-- *** replaceNamespacedResourceClaim

-- | @PUT \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaims\/{name}@
-- 
-- replace the specified ResourceClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedResourceClaim
  :: (Consumes ReplaceNamespacedResourceClaim contentType, MimeRender contentType V1alpha2ResourceClaim)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha2ResourceClaim -- ^ "body"
  -> Name -- ^ "name" -  name of the ResourceClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedResourceClaim contentType V1alpha2ResourceClaim accept
replaceNamespacedResourceClaim _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaims/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedResourceClaim 
instance HasBodyParam ReplaceNamespacedResourceClaim V1alpha2ResourceClaim 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedResourceClaim Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedResourceClaim DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedResourceClaim FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam ReplaceNamespacedResourceClaim FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedResourceClaim mtype

-- | @application/json@
instance Produces ReplaceNamespacedResourceClaim MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedResourceClaim MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedResourceClaim MimeYaml


-- *** replaceNamespacedResourceClaimStatus

-- | @PUT \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaims\/{name}\/status@
-- 
-- replace status of the specified ResourceClaim
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedResourceClaimStatus
  :: (Consumes ReplaceNamespacedResourceClaimStatus contentType, MimeRender contentType V1alpha2ResourceClaim)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha2ResourceClaim -- ^ "body"
  -> Name -- ^ "name" -  name of the ResourceClaim
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedResourceClaimStatus contentType V1alpha2ResourceClaim accept
replaceNamespacedResourceClaimStatus _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaims/",toPath name,"/status"]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedResourceClaimStatus 
instance HasBodyParam ReplaceNamespacedResourceClaimStatus V1alpha2ResourceClaim 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedResourceClaimStatus Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedResourceClaimStatus DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedResourceClaimStatus FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam ReplaceNamespacedResourceClaimStatus FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedResourceClaimStatus mtype

-- | @application/json@
instance Produces ReplaceNamespacedResourceClaimStatus MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedResourceClaimStatus MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedResourceClaimStatus MimeYaml


-- *** replaceNamespacedResourceClaimTemplate

-- | @PUT \/apis\/resource.k8s.io\/v1alpha2\/namespaces\/{namespace}\/resourceclaimtemplates\/{name}@
-- 
-- replace the specified ResourceClaimTemplate
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceNamespacedResourceClaimTemplate
  :: (Consumes ReplaceNamespacedResourceClaimTemplate contentType, MimeRender contentType V1alpha2ResourceClaimTemplate)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha2ResourceClaimTemplate -- ^ "body"
  -> Name -- ^ "name" -  name of the ResourceClaimTemplate
  -> Namespace -- ^ "namespace" -  object name and auth scope, such as for teams and projects
  -> KubernetesRequest ReplaceNamespacedResourceClaimTemplate contentType V1alpha2ResourceClaimTemplate accept
replaceNamespacedResourceClaimTemplate _  _ body (Name name) (Namespace namespace) =
  _mkRequest "PUT" ["/apis/resource.k8s.io/v1alpha2/namespaces/",toPath namespace,"/resourceclaimtemplates/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceNamespacedResourceClaimTemplate 
instance HasBodyParam ReplaceNamespacedResourceClaimTemplate V1alpha2ResourceClaimTemplate 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceNamespacedResourceClaimTemplate Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceNamespacedResourceClaimTemplate DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceNamespacedResourceClaimTemplate FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam ReplaceNamespacedResourceClaimTemplate FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceNamespacedResourceClaimTemplate mtype

-- | @application/json@
instance Produces ReplaceNamespacedResourceClaimTemplate MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceNamespacedResourceClaimTemplate MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceNamespacedResourceClaimTemplate MimeYaml


-- *** replaceResourceClass

-- | @PUT \/apis\/resource.k8s.io\/v1alpha2\/resourceclasses\/{name}@
-- 
-- replace the specified ResourceClass
-- 
-- AuthMethod: 'AuthApiKeyBearerToken'
-- 
replaceResourceClass
  :: (Consumes ReplaceResourceClass contentType, MimeRender contentType V1alpha2ResourceClass)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> Accept accept -- ^ request accept ('MimeType')
  -> V1alpha2ResourceClass -- ^ "body"
  -> Name -- ^ "name" -  name of the ResourceClass
  -> KubernetesRequest ReplaceResourceClass contentType V1alpha2ResourceClass accept
replaceResourceClass _  _ body (Name name) =
  _mkRequest "PUT" ["/apis/resource.k8s.io/v1alpha2/resourceclasses/",toPath name]
    `_hasAuthType` (P.Proxy :: P.Proxy AuthApiKeyBearerToken)
    `setBodyParam` body

data ReplaceResourceClass 
instance HasBodyParam ReplaceResourceClass V1alpha2ResourceClass 

-- | /Optional Param/ "pretty" - If 'true', then the output is pretty printed.
instance HasOptionalParam ReplaceResourceClass Pretty where
  applyOptionalParam req (Pretty xs) =
    req `addQuery` toQuery ("pretty", Just xs)

-- | /Optional Param/ "dryRun" - When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
instance HasOptionalParam ReplaceResourceClass DryRun where
  applyOptionalParam req (DryRun xs) =
    req `addQuery` toQuery ("dryRun", Just xs)

-- | /Optional Param/ "fieldManager" - fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
instance HasOptionalParam ReplaceResourceClass FieldManager where
  applyOptionalParam req (FieldManager xs) =
    req `addQuery` toQuery ("fieldManager", Just xs)

-- | /Optional Param/ "fieldValidation" - fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
instance HasOptionalParam ReplaceResourceClass FieldValidation where
  applyOptionalParam req (FieldValidation xs) =
    req `addQuery` toQuery ("fieldValidation", Just xs)

-- | @*/*@
instance MimeType mtype => Consumes ReplaceResourceClass mtype

-- | @application/json@
instance Produces ReplaceResourceClass MimeJSON
-- | @application/vnd.kubernetes.protobuf@
instance Produces ReplaceResourceClass MimeVndKubernetesProtobuf
-- | @application/yaml@
instance Produces ReplaceResourceClass MimeYaml

